

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The HTTP Spec and Symfony2 Fundamentals &mdash; symfony-docs-fr v0.1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="symfony-docs-fr v0.1 documentation" href="../index.html" />
    <link rel="up" title="Manuel" href="index.html" />
    <link rel="next" title="From flat PHP to Symfony2" href="from_flat_php_to_symfony2.html" />
    <link rel="prev" title="Manuel" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="from_flat_php_to_symfony2.html" title="From flat PHP to Symfony2"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Manuel"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">symfony-docs-fr v0.1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Manuel</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-http-spec-and-symfony2-fundamentals">
<span id="index-0"></span><h1>The HTTP Spec and Symfony2 Fundamentals<a class="headerlink" href="#the-http-spec-and-symfony2-fundamentals" title="Permalink to this headline">¶</a></h1>
<p>To go far with Symfony2, we&#8217;ll start first by discussing the Hypertext Transfer
Protocol (HTTP) - the refreshingly simple message format used by all clients
(e.g. web browsers) and servers when communicating with each other.
This is important because, as we&#8217;ll discover, Symfony2 has been tirelessly
architected at its core to use HTTP - not reinvent it. The end product
is a framework that, unlike many others, is an abstraction around the proven
fundamental rules of the World Wide Web. Whether you realize it or not,
HTTP is something you use everyday. With Symfony2, you&#8217;ll learn how to
leverage and master it.</p>
<div class="section" id="the-client-sends-the-request">
<span id="index-1"></span><h2>The Client sends the Request<a class="headerlink" href="#the-client-sends-the-request" title="Permalink to this headline">¶</a></h2>
<p>The Web is built around the idea that every communication begins when a client
makes a <em>request</em> to a server. The request is a simple text message created by
the client in a special format known as HTTP. Though there are many different
types of clients - web browser, web services, RSS reader, etc - each sends a
request with the same basic format. For example:</p>
<div class="highlight-text"><div class="highlight"><pre>GET /index.html HTTP/1.1
Host: www.example.com
Accept: text/html
User-Agent: Mozilla/5.0 (Linux; X11)
</pre></div>
</div>
<p>The first line of an HTTP request is the most important one (and as a matter
of fact, the only mandatory one). It contains two things: the URI and the
HTTP method. The URI (URL if combined with the host header) uniquely identifies
the location of the resource while the HTTP method defines what you want to
<em>do</em> with the resource. In this example, that unique location of the resource
is <tt class="docutils literal"><span class="pre">/index.html</span></tt> and the HTTP method is GET. In other words, the client&#8217;s
request is to retrieve the resource identified by <tt class="docutils literal"><span class="pre">/index.html</span></tt>.</p>
<p>The HTTP methods are the <em>verbs</em> of the HTTP request and define the few common
ways that we can act upon the resource:</p>
<ul class="simple">
<li><em>GET</em>  Retrieve the resource from the server;</li>
<li><em>POST</em> Create a resource on the server;</li>
<li><em>PUT</em>  Update the resource on the server;</li>
<li><em>DELETE</em> Delete the resource from the server.</li>
</ul>
<p>With this in mind, we can imagine what an HTTP request might look like to
delete a specific, say, a specific blog entry:</p>
<div class="highlight-text"><div class="highlight"><pre>DELETE /blog/15 HTTP/1.1
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There are actually nine HTTP methods defined by the HTTP specification,
but many of them are not widely used or supported. In reality, many modern
browsers don&#8217;t support the <tt class="docutils literal"><span class="pre">PUT</span></tt> and <tt class="docutils literal"><span class="pre">DELETE</span></tt> methods. One additional
header that <em>is</em> commonly supported is the <tt class="docutils literal"><span class="pre">HEAD</span></tt> method, which asks
for the response of an identical GET request, but without the response
body.</p>
</div>
<p>In addition to the first line, an HTTP request commonly contains other lines
of information known as HTTP request headers. The headers can supply a wide
array of additional information such as the requested <tt class="docutils literal"><span class="pre">Host</span></tt>, the response
formats the client accepts (<tt class="docutils literal"><span class="pre">Accept</span></tt>) and the application the client is
using to make the request (<tt class="docutils literal"><span class="pre">User-Agent</span></tt>). Many other headers exist and
can be found on Wikipedia&#8217;s <a class="reference external" href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields">List of HTTP header fields</a> article.</p>
</div>
<div class="section" id="the-server-returns-the-response">
<h2>The Server returns the Response<a class="headerlink" href="#the-server-returns-the-response" title="Permalink to this headline">¶</a></h2>
<p>Now that the server has read the HTTP-formatted request from the client, it
knows exactly which resource the client has identified (the URI) and what
the client would like to do with that resource (HTTP method). In the case
of a GET request, the server prepares the resource and returns it as an HTTP
response:</p>
<div class="highlight-text"><div class="highlight"><pre>HTTP/1.1 200 OK
Date: Fri, 12 Nov 2010 12:43:38 GMT
Server: Apache/2.2.14 (Ubuntu)
Connection: Keep-Alive
Content-Length: 563
Content-Type: text/html

&lt;html&gt;&lt;body&gt;Hello Symfony2 World!&lt;/body&gt;&lt;/html&gt;
</pre></div>
</div>
<p>The HTTP response returned by the server to the client contains not only
the requested resource (the HTML content in this case), but also other information
about the response. Like the HTTP request, the first line of the response
is especially important and contains the HTTP response status code (200 in
this case). The status code is extremely important and communicates the overall
outcome of the request back to the client. Different status codes exist for
successful requests, failed requests, and requests that require action from
the client (e.g. a redirect). A full list can be found on Wikipedia&#8217;s
<a class="reference external" href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">List of HTTP status codes</a> article.</p>
<p>Also like the request, an HTTP response message may contain additional pieces
of information. These are known as HTTP headers and sit between the first line
(the status code) and the response content.</p>
<p>One important HTTP response header is the <tt class="docutils literal"><span class="pre">Content-Type</span></tt>. The body of the
same resource may be returned in multiple different formats including HTML,
XML, or JSON to name a few. The <tt class="docutils literal"><span class="pre">Content-Type</span></tt> header tells the client
which format is being returned.</p>
<p>As we&#8217;ll find out, many other headers exist. Many are very powerful and can
be used, for example, to manage a powerful caching system.</p>
</div>
<div class="section" id="http-and-client-server-communication">
<h2>HTTP and Client-Server Communication<a class="headerlink" href="#http-and-client-server-communication" title="Permalink to this headline">¶</a></h2>
<p>This request-response exchange is the fundamental process that drives all
communication on the World Wide Web. And as important and powerful as this
process is, it&#8217;s inescapably simple. In fact, the rapid client-server communication
mirrors the way in which we send and receive email messages everyday. HTTP
is simply a commonly-understood language for these messages so that a disparate
set of applications and machines can communicate.</p>
<p>But why is a book about Symfony going to such lengths to explain requests,
responses, and the HTTP messaging format? Regardless of the framework you
choose, the type of application you build (web, mobile, JSON API), or the
development philosophy you follow, the end goal of the server is <em>always</em>
to understand each request and create and return the appropriate response.
Symfony is architected to match this reality.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">To learn more about the HTTP specification, we highly recommend reading
the original <a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP 1.1 RFC</a> or the <a class="reference external" href="http://datatracker.ietf.org/wg/httpbis/">HTTP Bis</a>, which is an active
effort to clarify the original specification. A great tool to check
both the request and response headers while browsing is the <a class="reference external" href="https://addons.mozilla.org/en-US/firefox/addon/3829/">Live HTTP Headers</a>
extension for Firefox.</p>
</div>
</div>
<div class="section" id="requests-and-responses-in-symfony">
<span id="index-2"></span><h2>Requests and Responses in Symfony<a class="headerlink" href="#requests-and-responses-in-symfony" title="Permalink to this headline">¶</a></h2>
<p>PHP comes packaged with an array of variables and methods that allow the developer
to understand each request and send a response. For request information,
PHP prepares superglobal variables such as <tt class="docutils literal"><span class="pre">$_SERVER</span></tt> and <tt class="docutils literal"><span class="pre">$_GET</span></tt>.
Recall that each raw request is simply an HTTP-formatted block of text.
The transformation of the request message into the superglobal variables
is done behind the scenes by PHP and your web server. The end result is that
the request message information is now available in PHP, but as a scattered
collection of different superglobals.</p>
<p>As object-oriented developers, we need a better (object-oriented) way to
access our request information. Symfony provides a <tt class="docutils literal"><span class="pre">Request</span></tt> class for
just that purpose. The <tt class="docutils literal"><span class="pre">Request</span></tt> class is simply an object-oriented
representation of an HTTP request message. With it, you have all the
request information at your fingertips:</p>
<div class="highlight-python"><pre>use Symfony\Component\HttpFoundation\Request;

$request = Request::createFromGlobals();

// the URI being requested ((e.g. /about) minus any query parameters
$request-&gt;getPathInfo();

// retrieve GET and POST variables respectively
$request-&gt;query-&gt;get('foo');
$request-&gt;request-&gt;get('bar');

// retrieves an instance of UploadedFile identified by foo
$request-&gt;files-&gt;get('foo');

$request-&gt;getMethod();          // GET, POST, PUT, DELETE, HEAD
$request-&gt;getLanguages();       // an array of accepted languages</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">getPathInfo()</span></tt> method is especially important as it returns the URI
being requested relative to your application. For example, suppose an
application is being executed from the <tt class="docutils literal"><span class="pre">foo</span></tt> subdirectory of a server. In
that case:</p>
<div class="highlight-python"><pre>// http://example.com/foo/index.php/bar
$request-&gt;getPathInfo();  // returns "bar"</pre>
</div>
<p>Symfony also provides a <tt class="docutils literal"><span class="pre">Response</span></tt> class, which is simply a PHP abstraction
of the raw HTTP response message. This allows your application to use an
object-oriented interface to construct response that needs to be returned
to the client:</p>
<div class="highlight-python"><pre>use Symfony\Component\HttpFoundation\Response;
$response = new Response();

$response-&gt;setContent('&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');
$response-&gt;setStatusCode(200);
$response-&gt;headers-&gt;set('Content-Type', 'text/html');

// echos the headers followed by the content
$response-&gt;send();</pre>
</div>
<p>At this point, if Symfony did nothing else, you would already have a
framework for accessing request information and an object-oriented
interface for creating the response. Symfony provides you with a rich toolset,
without obscuring the reality that <em>the end goal of any web application is
to process an HTTP request and return the appropriate HTTP response based on
the application-specific business logic</em>. Even as we discuss the many features
in Symfony, this goal will remain fundamental and transparent.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">The <tt class="docutils literal"><span class="pre">Request</span></tt> and <tt class="docutils literal"><span class="pre">Response</span></tt> classes are part of a standalone component
included with Symfony called <tt class="docutils literal"><span class="pre">HttpFoundation</span></tt>. This component can be
used entirely independent of Symfony and also provides classes for handling
sessions and file uploads.</p>
</div>
</div>
<div class="section" id="the-journey-from-the-request-to-the-response">
<h2>The Journey from the Request to the Response<a class="headerlink" href="#the-journey-from-the-request-to-the-response" title="Permalink to this headline">¶</a></h2>
<p>We know now that the end goal of any application is to use the HTTP
request to create and return the appropriate HTTP response. Symfony provides
<tt class="docutils literal"><span class="pre">Request</span></tt> and <tt class="docutils literal"><span class="pre">Response</span></tt> classes that allow this to be done through
an object-oriented interface. So far, we&#8217;re only leveraging a small
piece of Symfony. But we already have the tools to write a simple application!
Let&#8217;s dive in:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="x">$request = Request::createFromGlobals();</span>
<span class="x">$path = $request-&gt;getPathInfo(); // the URL being requested</span>
<span class="x">$method = $request-&gt;getMethod();</span>

<span class="x">if (in_array($path, array(&#39;&#39;, &#39;/&#39;) &amp;&amp; $method == &#39;GET&#39;) {</span>
<span class="x">    $response = new Response(&#39;Welcome to the homepage.&#39;);</span>
<span class="x">} elseif ($path == &#39;/about&#39; &amp;&amp; $method == &#39;GET&#39;) {</span>
<span class="x">    $response = new Response(&#39;About us&#39;);</span>
<span class="x">} else {</span>
<span class="x">    $response = new Response(&#39;Page not found.&#39;, 404);</span>
<span class="x">}</span>
<span class="x">$response-&gt;send();</span>
</pre></div>
</div>
<p>In this simple example, the application correctly processes the request and
returns an appropriate response. From a very technical standpoint, our
application does exactly what it should.</p>
<div class="section" id="an-application-without-a-framework">
<h3>An Application without a Framework<a class="headerlink" href="#an-application-without-a-framework" title="Permalink to this headline">¶</a></h3>
<p>But what if the application needs to grow? Imagine this same application if it
were now forced to handle hundreds or even thousands of different pages! In
order to keep things maintainable (i.e. not all in one file), we&#8217;d need to do
some reorganization. For starters, we might move the work of creating the
<tt class="docutils literal"><span class="pre">Response</span></tt> into a set of different functions. These functions are commonly
known as <em>controllers</em> and allow us to further organize our code:</p>
<div class="highlight-python"><pre>if (in_array($path, array('', '/')) &amp;&amp; $method == 'GET') {
    $response = main_controller($request);
} elseif ($path == '/about' &amp;&amp; $method == 'GET') {
    $response = about_controller($request);
} else {
    $response = error404_controller($request);
}

function main_controller(Request $request)
{
    return new Response('Welcome to the homepage.');
}

function about_controller(Request $request)
{
    return new Response('About us');
}

function error404_controller(Request $request)
{
    return new Response('Page not found.', 404);
}</pre>
</div>
<p>Next, our growing application still contains a long <tt class="docutils literal"><span class="pre">if</span></tt> <tt class="docutils literal"><span class="pre">elseif</span></tt> block
that routes the creation of the <tt class="docutils literal"><span class="pre">Response</span></tt> object to a different controller
(i.e. PHP method). We might consider building a configuration-based routing
system that maps each request to a specific controller based on the URI and
HTTP method of the request.</p>
<p>Obvious or not, the application is beginning to spin out of control. Recall
that the goal of any application is to apply the custom application logic and
information from the request to create an appropriate response. In our
application, these proposed changes are <strong>not</strong> to the business logic. Instead,
the necessary refactoring means inventing a system of controllers and a custom
routing system. As we continue development, we&#8217;ll inevitably spend some time
developing our application and some time developing and enhancing the framework
around it.</p>
<p>We need a better solution - one where the developer spends his/her time developing
the application logic for creating <tt class="docutils literal"><span class="pre">Response</span></tt> objects instead of on so many
low-level details.</p>
<p>The Symfony framework does just this by allowing you to focus on your most
valuable deliverables without sacrificing the power and organization of a
framework. Of course, a popular framework like Symfony comes with a long
list of &#8220;bonuses&#8221; such as free maintenance, documentation, standardization,
and a community-driven group of open source bundles (i.e. plugins) available
for use.</p>
</div>
<div class="section" id="introducing-the-symfony-kernel">
<span id="index-3"></span><h3>Introducing the Symfony Kernel<a class="headerlink" href="#introducing-the-symfony-kernel" title="Permalink to this headline">¶</a></h3>
<p>Symfony is based around a <tt class="docutils literal"><span class="pre">Kernel</span></tt> object whose single responsibility is to facilitate
the journey from the <tt class="docutils literal"><span class="pre">Request</span></tt> object to the final <tt class="docutils literal"><span class="pre">Response</span></tt> object.
The <tt class="docutils literal"><span class="pre">Kernel</span></tt> is what handles each request and actually executes your application
code.</p>
<p>The &#8220;application code&#8221; executed by the <tt class="docutils literal"><span class="pre">Kernel</span></tt> is called a &#8220;controller&#8221;,
a special term for what&#8217;s actually a basic PHP callable (most commonly,
an object method). The controller is where your application code lives -
it&#8217;s where you create the final <tt class="docutils literal"><span class="pre">Response</span></tt> object. The <tt class="docutils literal"><span class="pre">Kernel</span></tt> works by
determining and then calling a &#8220;Controller&#8221; for each request:</p>
<div class="highlight-text"><div class="highlight"><pre>Request -&gt; Kernel::handle() -&gt; Controller (your code) -&gt; Response (returned by controller)
</pre></div>
</div>
<p>Our original sample application could be refactored into two &#8220;controllers&#8221;,
which, in this example, are PHP methods in some <tt class="docutils literal"><span class="pre">myController</span></tt> class.
The code needed to determine and execute these controllers is isolated
elsewhere and handled by the <tt class="docutils literal"><span class="pre">Kernel</span></tt>:</p>
<div class="highlight-python"><pre>class myController
{
    public function homepageAction()
    {
        return new Response('Welcome to the homepage.');
    }

    public function aboutAction()
    {
        return new Response('About us');
    }
}</pre>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Notice that each controller returns a <tt class="docutils literal"><span class="pre">Response</span></tt> object. This is the
basic job of your controllers: to apply complex business logic and
ultimately construct and return the final <tt class="docutils literal"><span class="pre">Response</span></tt>.</p>
</div>
<p>But how does the <tt class="docutils literal"><span class="pre">Kernel</span></tt> know which controller to call for each request?
Though this process is entirely configurable, Symfony2 integrates a <tt class="docutils literal"><span class="pre">Router</span></tt>
that uses a &#8220;map&#8221; to connect path info from the <tt class="docutils literal"><span class="pre">Request</span></tt> to a specific
controller.</p>
<div class="highlight-text"><div class="highlight"><pre>Request -&gt; Kernel::handle() -&gt; Controller -&gt; Response
                    |    ^
                    | controller
                    |    |
                    v    |
                    Routing
</pre></div>
</div>
<p>We&#8217;ll talk a lot more about <a class="reference internal" href="controller.html"><em>Controllers</em></a> and the
<a class="reference internal" href="routing.html"><em>Router</em></a> in later chapters.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">The <tt class="docutils literal"><span class="pre">Kernel</span></tt> class is part of a standalone component used by Symfony2
called <tt class="docutils literal"><span class="pre">HttpKernel</span></tt>. This component provides functionality related to
Bundles, Security, Caching and more. The <tt class="docutils literal"><span class="pre">Router</span></tt> is also part of a
standalone component called <tt class="docutils literal"><span class="pre">Routing</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="symfony2-components-versus-the-symfony2-framework">
<span id="index-4"></span><h2>Symfony2 <em>Components</em> versus the Symfony2 <em>Framework</em>?<a class="headerlink" href="#symfony2-components-versus-the-symfony2-framework" title="Permalink to this headline">¶</a></h2>
<p>By now, we&#8217;ve seen the most basic components that make up the Symfony2 framework.
In reality, everything we&#8217;ve talked about so far (the <tt class="docutils literal"><span class="pre">Request</span></tt>, <tt class="docutils literal"><span class="pre">Response</span></tt>,
<tt class="docutils literal"><span class="pre">Kernel</span></tt> and <tt class="docutils literal"><span class="pre">Router</span></tt>) lives in three different standalone components
used by Symfony. In fact, each feature in Symfony2 belongs to one of over
twenty independent libraries (called the &#8220;Symfony Components&#8221;)! Even if you
decided to build your own PHP framework (an unwise idea), you could use the
Symfony Components as the building blocks for many layers of functionality.
And if you do use Symfony2, but need to replace a component entirely, you have
the ability to do that. Symfony2 is decoupled and relies on interface-driven
dependency injection. In other words, the developer has complete control.</p>
<p>So then, what <em>is</em> the Symfony2 <strong>Framework</strong>? The <em>Symfony2 Framework</em> is
a PHP framework that accomplishes two distinct tasks:</p>
<ol class="arabic simple">
<li>Provides a selection of components (i.e. the Symfony2 Components) and
third-party libraries.</li>
<li>Provides sensible configuration that nicely ties everything together.</li>
</ol>
<p>The goal of the framework is to integrate many independent tools in order
to provide a consistent experience for the developer. Even the framework
itself is a Symfony2 bundle that can be configured or replaced entirely.</p>
<p>Basically, Symfony2 provides a powerful set of tools for rapidly developing
web applications without imposing on your application. Normal users can
quickly start development by using a Symfony2 distribution, which provides
a project skeleton with sensible defaults. For more advanced users, the sky
is the limit.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The HTTP Spec and Symfony2 Fundamentals</a><ul>
<li><a class="reference internal" href="#the-client-sends-the-request">The Client sends the Request</a></li>
<li><a class="reference internal" href="#the-server-returns-the-response">The Server returns the Response</a></li>
<li><a class="reference internal" href="#http-and-client-server-communication">HTTP and Client-Server Communication</a></li>
<li><a class="reference internal" href="#requests-and-responses-in-symfony">Requests and Responses in Symfony</a></li>
<li><a class="reference internal" href="#the-journey-from-the-request-to-the-response">The Journey from the Request to the Response</a><ul>
<li><a class="reference internal" href="#an-application-without-a-framework">An Application without a Framework</a></li>
<li><a class="reference internal" href="#introducing-the-symfony-kernel">Introducing the Symfony Kernel</a></li>
</ul>
</li>
<li><a class="reference internal" href="#symfony2-components-versus-the-symfony2-framework">Symfony2 <em>Components</em> versus the Symfony2 <em>Framework</em>?</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Manuel</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="from_flat_php_to_symfony2.html"
                        title="next chapter">From flat PHP to Symfony2</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/book/http_fundamentals.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="from_flat_php_to_symfony2.html" title="From flat PHP to Symfony2"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Manuel"
             >previous</a> |</li>
        <li><a href="../index.html">symfony-docs-fr v0.1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Manuel</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>